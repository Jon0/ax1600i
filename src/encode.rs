pub(crate) const ENCODE_TABLE: [u8; 16] = [
    0x55, 0x56, 0x59, 0x5a, 0x65, 0x66, 0x69, 0x6a, 0x95, 0x96, 0x99, 0x9a, 0xa5, 0xa6, 0xa9, 0xaa
];

pub(crate) const DECODE_TABLE: [u8; 256] = [
    0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
    0x20, 0x21, 0x00, 0x12, 0x22, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x24,
    0x25, 0x00, 0x16, 0x26, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x28, 0x29, 0x00, 0x1a,
    0x2a, 0x2b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x2c, 0x2d, 0x00, 0x1e, 0x2e,
    0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00
];

pub fn encode(command: usize, msg: &[u8]) -> Vec<u8> {
    let size = msg.len();
    let newsize = (size * 2) + 2;

    let mut ret = Vec::new();
    ret.resize(newsize, 0x00);

    ret[0] = ENCODE_TABLE[(command << 1) & 0xf] & 0xfc;
    ret[newsize - 1] = 0;

    let mut i = 1;
    let mut j = 1;
    while i <= size {
        ret[j] = ENCODE_TABLE[(msg[i - 1] & 0xf) as usize];
        j += 1;

        ret[j] = ENCODE_TABLE[(msg[i - 1] >> 4) as usize];
        j += 1;

        i += 1;
    }
    return ret;
}

pub fn decode(msg: &[u8]) -> Vec<u8> {
    let new_size = msg.len() / 2;
    let mut result = Vec::new();
    if new_size == 0 {
        return result;
    }
    result.resize(new_size, 0x00);

    if ((DECODE_TABLE[msg[0] as usize] & 0xf) >> 1) != 7 {
        println!("decode_answer: wrong reply data: {} (data {})\n", ((DECODE_TABLE[msg[0] as usize] & 0xf) >> 1), msg[0]);
    }
    let mut i = 1;
    let mut j = 0;
    while i <= msg.len() {
        let a = *msg.get(i).unwrap_or(&0) as usize;
        let b = *msg.get(i + 1).unwrap_or(&0) as usize;
        result[j] = (DECODE_TABLE[a] & 0xf) | ((DECODE_TABLE[b] & 0xf) << 4);
        i += 2;
        j += 1;
    }
    return result;
}